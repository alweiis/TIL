# 트랜잭션

### 다중 사용자 데이터베이스

- 잠금

  - 잠금은 데이터베이스 서버가 데이터 자원의 동시 사용을 제어하는 데 사용하는 메커니즘

  - 데이터베이스의 일부가 잠기면 해당 데이터를 수정하거나 읽으려는 다른 사용자는 잠금이 해제될 때까지 기다려야 한다.

  - 데이터베이스 서버의 두 가지 잠금 방식

    1. 데이터베이스 writer는 데이터를 수정하기 위해 `쓰기 잠금(writer lock)`을 서버에 요청하고 수신해야 하며, 
       데이터베이스 reader는 데이터를 조회하기 위해 서버에 `읽기 잠금(read lock)`을 요청하고 수신해야 한다. 
       이 방식은 여러 사용자가 동시에 데이터를 읽을 수 있지만 각 테이블(또는 그 일부)에 대해 한 번에 하나의 쓰기 잠금만 
       제공하고 쓰기 잠금이 해제될 때까지는 읽기 요청이 차단된다.
    2. 데이터베이스 writer는 데이터를 수정하기 위해 쓰기 잠금을 서버에 요청하고 수신해야 하지만, 
       reader가 데이터를 조회할 때는 어떠한 유형의 잠금도 필요하지 않다. 
       대신 서버는 쿼리가 시작될 때부터 쿼리가 완료될 때까지 reader에게 데이터에 대한 일관된 보기를 제공한다(다른 사용자가 수정을 하더라도 데이터는 동일하게 보인다). 이 접근 방식을 `버전관리versioning`라고 한다.

    - 두 가지 접근 방식은 모두 장단점을 가지고 있는데, 첫 번째 방법은 동시 읽기와 쓰기 요청이 많으면 대기 시간이 길어질 수 있고, 두 번째 방법은 데이터를 수정하는 동안 오래 실행되는 쿼리가 있으면 문제가 될 수 있다.
    - SQL Server는 첫 번째 방식을 사용하고, Oracle 데이터베이스는 두 번째 접근 방식을 사용하며, MySQL은 두 가지 접근 방식을 모두 사용한다. (`스토리지 엔진` 선택에 따라 달라진다.)

- 잠금 단위

  - 테이블 잠금(table locks)
    - 여러 사용자가 동일한 테이블의 데이터를 동시에 수정할 수 없다.
  - 페이지 잠금(page locks)
    - 여러 사용자가 테이블의 동일한 페이지의 데이터를 동시에 수정할 수 없다.
  - 행 잠금(row locks)
    - 여러 사용자가 테이블의 동일한 행을 동시에 수정할 수 없다.
  - SQL Server는 페이지, 행, 테이블 잠금을 사용하고, Oracle 데이터베이스는 행 잠금만 사용하며, MySQL은 테이블, 페이지 또는 행 잠금을 사용한다(스토리지 엔진에 따라 다르다).

<br>

### 트랜잭션

- 트랜잭션은 여러 SQL 문을 함께 그룹화해서 `모든` 구문이 성공하거나 성공하지 `않도록`하는 장치이다.

#### 	트랜잭션 시작

- 데이터베이스 서버는 다음 두 가지 방법 중 하나로 트랜잭션 생성을 처리한다.
  - 활성 트랜잭션은 항상 데이터베이스 세션과 연결되어 있으므로 명시적 트랜잭션을 시작할 필요나 방법이 없다.
    현재 트랜잭션이 종료되면 서버는 자동으로 세션에 대한 새 트랜잭션을 시작한다.
  - 명시적으로 트랜잭션을 시작하지 않는 한 개별 SQL 문은 서로 독립적으로 자동 커밋된다.
    트랜잭션을 시작하려면 먼저 시작 명령어를 실행해야 한다.
    - Oracle 데이터베이스는 첫 번째 접근 방식을 사용하고 SQL Server와 MySQL은 두 번째 접근 방식을 사용한다.
      Oracle의 트랜잭션 접근 방식의 장점 중 하나는 단일 SQL 구문만 실행하더라도 결과가 마음에 들지 않다면 
      변경 사항을 롤백할 수 있다는 점이다.
    - 하지만 MySQL과 SQL Server에서는 Enter 키를 누르면 SQL 문의 변경 사항이 영구 적용된다.
- MySQL에서 `start transaction` 명령어를 사용해서 트랜잭션을 시작 할 수 있다.

#### 	트랜잭션 종료

- commit : 서버가 변경 사항을 영구적으로 적용하고 트랜잭션 중에 사용된 모든 리소소(페이지 또는 행 잠금 등)를 해제하도록 지시한다.
- rollback : 트랜잭션 시작 이후의 모든 변경 사항을 실행 취소하고, 트랜잭션 전 상태로 되돌리도록 서버에 지시한다. 롤백이 완료되면 세션에서 사용된 모든 리소스가 해제된다.
- commit 또는 rollback 명령어를 실행했을 때 뿐만 아니라 다음과 같은 작업의 간접적인 결과 또는 제어할 수 없는 어떤 이유로 트랜잭션이 종료될 수 있다.
  - 서버가 종료되고 서버가 재시작되면서 트랜잭션이 자동으로 롤백된다.
  - alter table과 같은 SQL 스키마 문을 실행하면 현재 트랜잭션이 커밋되고 새로운 트랜잭션이 시작된다.
  - 다른 start transaction 명령어를 실행하면 이전 트랜잭션이 커밋된다.
  - 서버가 `교착 상태(deadlock)`를 감지했을 때 해당 트랜잭션이 원인이라고 판단되면 서버는 트랜잭션을 조기 종료한다.
    이 경우 트랜잭션이 롤백되고 오류 메시지가 표시된다.
- 교착 상태(Deadlock) : 두 개의 서로 다른 트랜잭션이 다른 트랜잭션이 현재 보유하고 있는 리소스를 대기할 때 발생한다.
  - 예를 들어 트랜잭션 a가 A 테이블을 업데이트하고 B 테이블에 대한 쓰기 잠금을 기다리고 있는 반면, 
    트랜잭션 b는 B 테이블에 행을 삽입하고 a 테이블에 대한 쓰기 잠금을 기다리고 있을 수 있다.
  - 이처럼 두 트랜잭션이 동일한 페이지 또는 행을 수정할 경우, 각 트랜잭션은 다른 트랜잭션이 완료되고 필요한 리소스를 확보할 때까지 영원히 기다린다. 
  - 이러한 교착 상태가 감지되면 트랜잭션 중 하나를(임의로 또는 일부 기준에 따라) 선택해서 다른 트랜잭션이 진행될 수 있도록 롤백한다. 대부분의 경우 종료된 트랜잭션은 다시 시작할 수 있으므로 다른 교착 생태가 발생하지 않고 성공한다.

#### 트랜잭션 세이브포인트

- 경우에 따라 트랜잭션 내에서 문제가 발생하여 전체를 롤백할 수도 있지만 실행한 `모든` 작업을 취소하지 않을 수도 있다.
- 이런 상황에서는 트랜잭션 내에 하나 이상의 `세이브포인트`를 설정하고, 이를 사용해서 트랜잭션 시점으로 완전히 롤백하는 대신
  트랜잭션 내의 특정 위치로 롤백할 수 있다.

<br>

#### **스토리지 엔진 선택**

- MySQL은 리소스 잠금과 트랜잭션 관리를 포함한 낮은 수준의 데이터베이스 기능을 제공하기 위해 여러 스토리지 엔진을 활용할 수 있도록 설계되었다. MySQL 8.0 버전에는 다음과 같은 스토리지 엔진이 포함되어 있다.
  - MyISAM : 테이블 잠금을 사용하는 넌트랜잭션(nontransaction) 엔진
  - MEMORY : 인메모리 테이블에 사용되는 넌트랜잭션 엔진
  - CSV : 데이터를 쉼표로 구분해서 파일에 저장하는 트랜잭션 엔진
  - InnoDB : 행 수준 잠금을 사용하는 트랜잭션 엔진
  - Merge : 여러 개의 MyISAM 테이블을 단일 테이블로 표시하는 특수 엔진(일명 테이블 분할)
  - Archive : 주로 보관 목적으로 대량의 인덱싱되지 않은 데이터를 저장하는 특수 엔진
- MySQL은 테이블별로 스토리지 엔진을 선택할 수 있을 만큼 유연하지만 트랜잭션을 사용해야 하는 테이블의 경우에는 
  행 수준 잠금과 버전 관리를 제공하며 여러 스토리지 엔진 중에서도 최고 수준의 동시성을 제공하는 `InnoDB` 엔진을 선택해야 한다.