# 인터페이스(interface)
## 인터페이스란?
- 일종의 추상클래스
- 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아 추상클래스와 달리 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.
- 오직 추상메서드와 상수만을 멤버로 가질 수 있다.
- 추상클래스와 같이 그 자체만으로 사용되기 보다 다른 클래스를 작성하는데 도움을 줄 목적으로 사용된다.
<br><br>
## 인터페이스의 작성
- 클래스를 작성하는 것과 같지만 키워드 class 대신 interface를 사용한다.
- 접근제어자로 public 또는 default를 사용할 수 있다.
```java
interface 인터페이스이름 {
    pulic static final 타입 상수이름 = 값;
    pulic abstract 메서드이름(매개변수목록);
}
```
- **인터페이스 제약사항**
  - 모든 멤버변수는 public static final 이며, 이를 생략할 수 있다.
  - 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다. (단, static 메서드와 default 메서드는 JDK 1.8부터 예외)
  <br><br>
## 인터페이스의 상속
- 인터페이스는 인터페이스로부터만 상속받을 수 있다.
- 클래스와는 달리 다중상속을 지원한다.
- 클래스와는 달리 Object 클래스와 같은 최고 조상이 없다.
```java
interface Movable {
    void move(int x, int y);
}

interface Attackable {
    void attack(Unit u);
}

interface Fightable extends Movable, Attackable {}
```
## 인터페이스의 구현
- 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없다.
- 자신에 정의된 추상메서드의 몸통(구현부)를 만들어주는 클래스를 작성하기 위해 키워드 implements를 사용한다.
```java
class 클래스이름 implements 인터페이스이름 {
    // 인터페이스에 정의된 추상메서드를 구현해야 한다.
}
```
- 구현하는 인터페이스의 메서드 중 일부만 구현한다면, abstract를 붙여서 추상 클래스로 선언해야 한다.
```java
abstract class Fighter implements Fightable {
    public void move(int x, int y) {}
}
```
- 클래스의 상속과 인터페이스의 구현을 동시에 할 수 있다.
<br><br>
## 인터페이스를 이용한 다형성
- 인터페이스는 인터페이스를 구현한 클래스의 조상이라고 할 수 있다.
- 따라서 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다.
- 또, 인터페이스 타입으로 형변환도 가능하다.
- 인터페이스 타입의 매개변수가 가는 의미는?
  - 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스터스를 매개변수로 제공해야 한다.

**리턴타입이 인터페이스라면,**
- 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.
```java
Fightable method() {
    ...
    return new Fighter();
}
```
- 위의 코드에서 method()의 리턴타입이 Fightable 인터페이스이기 때문에 메서드의 return문에서 Fightable 인터페이스를 구현한 Fighter 클래스의 인스턴스를 반환한다,
<br><br>
## 인터페이스의 장점
- 개발시간을 단축시킬 수 있다.
- 표준화가 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
- 독립적인 프로그래밍이 가능하다.
<br><br>
## 인터페이스의 이해
- 클래스를 사용하는 쪽(User)과 제공하는 쪽(Provider)이 있다.
- 메서드를 사용(호출)하는 쪽에서는 사용하려는 메서드의 선언부만 알면 된다.(내용은 몰라도 된다.)
```java
class A {
    public void methodA(B b) {
        b.methodB();
    }
}

class B {
    public void methodB() {
        System.out.println("methodB()");
    }
}

class InterfaceTest {
    public static void main(String args[]) {
        A a = new A();
        a.methodA(new B());
    } 
}
```
위의 코드에서 클래스 A는 클래스 B의 인스턴스를 생성하고 메서드를 호출한다. 이 두 클래스는 서로 직접적인 관계에 있다.<br>
직접적인 관계의 두 클래스는 한 쪽(Provider)이 변경되면 다른 한 쪽(User)도 변경되어야 한다.<br>
클래스 간의 관계를 직접적인 관계에서 인터페이스를 사용한 간접적인 관계로 변경해주면 클래스의 변경에 유동적으로 대처할 수 있다.

**간접적인 관계를 만드는 2가지 방법**
1. 매개변수를 통해 인터페이스 I를 구현한 클래스의 인스턴스를 동적으로 제공받게 한다.
2. 인스턴스를 직접 생성하지 않고, 제 3의 클래스의 메서드를 통해 제공받게 한다.
<br><br>
## 디폴트 메서드(default method)
- 추상 메서드의 기본적인 구현을 제공하는 메서드로, 추상 메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.
- 메서드에 키워드 default를 붙인다.
- 추상 메서드와 달리 일반 메서드처럼 몸통{ }이 있어야 한다.
- 접근 제어자는 public이며, 생략이 가능하다. 

### 📝참고 문헌

- Java의 정석 3판 (도우출판, 남궁 성 지음)